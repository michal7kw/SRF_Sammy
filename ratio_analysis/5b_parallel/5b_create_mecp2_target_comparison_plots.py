#!/usr/bin/env python3
"""
SAMMY-seq Mecp2 Target Comparison - Plot Generation

This script combines the results from the parallel metaprofile computations
and generates the final heatmaps and line plots.

It reads the pickle files generated by the parallel jobs and creates:
1. A 2x2 grid of heatmaps for the different gene sets
2. A 2x2 grid of line plots for clearer comparison
"""

import os
import sys
import argparse
import logging
import glob
import pickle
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import LinearSegmentedColormap
import seaborn as sns
from mpl_toolkits.axes_grid1 import make_axes_locatable
from scipy.ndimage import gaussian_filter1d

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("mecp2_plots.log"),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger('SAMMY-seq-Mecp2-Plots')

def parse_arguments():
    """Parse command line arguments"""
    parser = argparse.ArgumentParser(description='SAMMY-seq Mecp2 Target Comparison Plot Generation')
    parser.add_argument('--input-dir', required=True, help='Directory containing metaprofile matrices')
    parser.add_argument('--output-dir', required=True, help='Output directory for plots')
    return parser.parse_args()

def load_matrices(input_dir):
    """
    Load all metaprofile matrices from the input directory.
    
    Args:
        input_dir (str): Directory containing the metaprofile matrices.
        
    Returns:
        dict: A dictionary where keys are gene set names and values are dictionaries
              of condition-specific matrices.
    """
    logger.info(f"Loading matrices from {input_dir}")
    
    # Dictionary to store matrices for each gene set and condition
    condition_matrices = {}
    
    # Find all pickle files in the input directory
    matrix_files = glob.glob(os.path.join(input_dir, "*_matrix.pkl"))
    
    if not matrix_files:
        logger.error(f"No matrix files found in {input_dir}")
        return {}
    
    logger.info(f"Found {len(matrix_files)} matrix files")
    
    # Load each matrix file
    for matrix_file in matrix_files:
        try:
            with open(matrix_file, 'rb') as f:
                data = pickle.load(f)
            
            gene_set = data['gene_set']
            condition = data['condition']
            matrix = data['matrix']
            
            # Initialize the gene set dictionary if it doesn't exist
            if gene_set not in condition_matrices:
                condition_matrices[gene_set] = {}
            
            # Store the matrix
            condition_matrices[gene_set][condition] = matrix
            
            logger.info(f"Loaded matrix for {gene_set}, {condition} with shape {matrix.shape}")
        
        except Exception as e:
            logger.error(f"Error loading matrix file {matrix_file}: {e}")
    
    # Log all available conditions for each gene set
    for gene_set in condition_matrices:
        logger.info(f"Gene set {gene_set} has conditions: {list(condition_matrices[gene_set].keys())}")
    
    return condition_matrices

def create_comparison_heatmap(gene_sets, condition_matrices, output_file, 
                             upstream_bins, gene_body_bins, downstream_bins,
                             bin_size, upstream_distance, downstream_distance):
    """
    Create a 2x2 grid of heatmaps comparing Mecp2 target and non-target genes.
    
    Args:
        gene_sets (list): A list of gene set names (e.g., 'NEU_target', 'NSC_non_target').
        condition_matrices (dict): A dictionary where keys are gene set names and
                                   values are dictionaries of condition-specific matrices.
        output_file (str): The path to save the generated heatmap figure.
        upstream_bins (int): The number of bins representing the upstream region.
        gene_body_bins (int): The number of bins representing the gene body.
        downstream_bins (int): The number of bins representing the downstream region.
        bin_size (int): Size of each bin in the metaprofile (bp).
        upstream_distance (int): Distance upstream of the TSS to consider (bp).
        downstream_distance (int): Distance downstream of the TES to consider (bp).
    """
    logger.info(f"Creating comparison heatmap")
    
    try:
        # Create a custom colormap with more contrast: blue for heterochromatin, white for undefined, red for euchromatin
        cmap = LinearSegmentedColormap.from_list(
            'custom_diverging',
            [(0, '#0000FF'), (0.45, '#8080FF'), (0.5, 'white'), (0.55, '#FF8080'), (1, '#FF0000')],
            N=256
        )
        
        # Set up the figure with 2x2 grid
        fig, axes = plt.subplots(2, 2, figsize=(16, 12))
        
        # Set vmin and vmax for consistent color scaling across all heatmaps
        # Use tighter bounds to enhance contrast
        vmin = -0.05
        vmax = 0.05
        
        # Define the order of gene sets to display
        gene_set_order = ['NEU_target', 'NEU_non_target', 'NSC_target', 'NSC_non_target']
        
        # Define display names for gene sets
        gene_set_display = {
            'NEU_target': 'NEU Mecp2 target genes',
            'NEU_non_target': 'NEU non-target genes',
            'NSC_target': 'NSC Mecp2 target genes',
            'NSC_non_target': 'NSC non-target genes'
        }
        
        # Define the positions for each gene set in the 2x2 grid
        positions = {
            'NEU_target': (0, 0),  # Row 0, Column 0
            'NEU_non_target': (0, 1), # Row 0, Column 1
            'NSC_target': (1, 0),  # Row 1, Column 0
            'NSC_non_target': (1, 1)  # Row 1, Column 1
        }
        
        # Define the order of conditions to display
        # Make sure these match exactly with the condition names in the files
        condition_order = ['NSC_GFP', 'NSC_M2', 'Neu_GFP', 'Neu_M2']
        
        # Iterate through each gene set to create its corresponding heatmap
        for gene_set in gene_set_order:
            row, col = positions[gene_set]  # Get the row and column for the current gene set
            
            # Get the matrices for this gene set
            matrices = condition_matrices.get(gene_set, {})
            
            # If no matrices are found for this gene set, log a warning and skip to the next gene set
            if not matrices:
                logger.warning(f"No matrices found for {gene_set}, skipping")
                continue
            
            # Log available conditions for this gene set
            logger.info(f"Available conditions for {gene_set}: {list(matrices.keys())}")
            
            # Initialize variables to store the averaged matrix data and the conditions with valid data
            matrix_data = None
            conditions_with_data = []
            
            # Iterate through each condition to compute the average profile
            for condition in condition_order:
                # Check if the condition exists in the matrices and if the data is not None
                if condition in matrices and matrices[condition] is not None:
                    # Average across genes for each position
                    avg_profile = np.nanmean(matrices[condition], axis=0)
                    
                    # Apply smoothing to reduce noise and highlight patterns
                    avg_profile = gaussian_filter1d(avg_profile, sigma=2)
                    
                    # If matrix_data is None, initialize it with the first average profile
                    if matrix_data is None:
                        matrix_data = avg_profile.reshape(1, -1)
                    # Otherwise, stack the current average profile onto the existing matrix_data
                    else:
                        matrix_data = np.vstack([matrix_data, avg_profile.reshape(1, -1)])
                    
                    # Append the condition to the list of conditions with valid data
                    conditions_with_data.append(condition)
                else:
                    logger.warning(f"Condition {condition} not found for gene set {gene_set}")
            
            # If no valid data is found for the gene set, log a warning and skip to the next gene set
            if matrix_data is None or matrix_data.size == 0:
                logger.warning(f"No valid data for {gene_set}, skipping")
                continue
            
            # Create heatmap
            ax = axes[row, col]  # Get the axis object for the current gene set
            
            # Create the heatmap with enhanced parameters
            sns.heatmap(matrix_data, cmap=cmap, vmin=vmin, vmax=vmax, 
                       cbar=True, ax=ax, yticklabels=conditions_with_data,
                       xticklabels=False, rasterized=True)
            
            # Add vertical lines to mark TSS and TES
            ax.axvline(x=upstream_bins, color='black', linestyle='--', linewidth=1)
            ax.axvline(x=upstream_bins + gene_body_bins, color='black', linestyle='--', linewidth=1)
            
            # Set title with larger font
            ax.set_title(gene_set_display[gene_set], fontsize=14, fontweight='bold')
            
            # Set x-axis labels
            total_bins = upstream_bins + gene_body_bins + downstream_bins
            xticks = [0, upstream_bins, upstream_bins + gene_body_bins, total_bins]
            xticklabels = [f"-{upstream_distance/1000}kb", "TSS", "TES", f"+{downstream_distance/1000}kb"]
            ax.set_xticks(xticks)
            ax.set_xticklabels(xticklabels, fontsize=12)
            
            # Add colorbar label
            cbar = ax.collections[0].colorbar
            cbar.set_label('log2(S2S/S3)', fontsize=12)
            
            # Add a line plot below the heatmap to better visualize differences
            divider = make_axes_locatable(ax)
            ax_line = divider.append_axes("bottom", size="30%", pad=0.5)
            
            # Plot each condition as a line
            for i, condition in enumerate(conditions_with_data):
                ax_line.plot(matrix_data[i], label=condition, linewidth=2)
            
            # Add vertical lines to mark TSS and TES in line plot
            ax_line.axvline(x=upstream_bins, color='black', linestyle='--', linewidth=1)
            ax_line.axvline(x=upstream_bins + gene_body_bins, color='black', linestyle='--', linewidth=1)
            
            # Set y-limits for line plot to enhance visibility of differences
            y_min = np.min(matrix_data) - 0.01
            y_max = np.max(matrix_data) + 0.01
            ax_line.set_ylim(y_min, y_max)
            
            # Add legend to line plot
            ax_line.legend(loc='upper right', fontsize=10)
            
            # Set x-axis labels for line plot
            ax_line.set_xticks(xticks)
            ax_line.set_xticklabels(xticklabels, fontsize=12)
            
            # Set y-axis label for line plot
            ax_line.set_ylabel('log2(S2S/S3)', fontsize=12)
        
        # Set overall title
        plt.suptitle("Mecp2 repressed genes SAMMY metaprofile", fontsize=18, fontweight='bold')
        
        # Add a color legend and bin information to the figure
        fig.subplots_adjust(bottom=0.2)  # Make room for the legend at the bottom
        
        # Create a new axis for the color legend
        color_legend_ax = fig.add_axes([0.15, 0.08, 0.7, 0.05])
        
        # Create a gradient for the color legend
        gradient = np.linspace(vmin, vmax, 256).reshape(1, -1)
        color_legend_ax.imshow(gradient, aspect='auto', cmap=cmap)
        color_legend_ax.set_xticks([0, 128, 255])
        color_legend_ax.set_xticklabels([f"{vmin} (Heterochromatin)", "0 (Undefined)", f"{vmax} (Euchromatin)"])
        color_legend_ax.set_yticks([])
        color_legend_ax.set_title("Color Scale: log2(S2S/S3)", fontsize=12)
        
        # Add bin information
        bin_info_text = (
            f"Bin Information:\n"
            f"Upstream region: {upstream_bins} bins (each {bin_size}bp) = {upstream_distance}bp\n"
            f"Gene body: {gene_body_bins} bins (scaled to gene length)\n"
            f"Downstream region: {downstream_bins} bins (each {bin_size}bp) = {downstream_distance}bp"
        )
        fig.text(0.5, 0.02, bin_info_text, ha='center', fontsize=12, bbox=dict(facecolor='white', alpha=0.8, boxstyle='round,pad=0.5'))
        
        # Adjust layout
        plt.tight_layout(rect=[0, 0.2, 1, 0.96])  # Make room for suptitle and legend
        
        # Save the figure
        plt.savefig(output_file, dpi=300)
        
        # Create a second figure with individual line plots for clearer comparison
        plt.figure(figsize=(16, 12))
        
        # Iterate through each gene set to create individual line plots
        for i, gene_set in enumerate(gene_set_order):
            plt.subplot(2, 2, i+1)  # Create a subplot for each gene set
            
            matrices = condition_matrices.get(gene_set, {})
            if not matrices:
                continue
                
            # Plot the average profile for each condition
            for condition in condition_order:
                if condition in matrices and matrices[condition] is not None:
                    avg_profile = np.nanmean(matrices[condition], axis=0)
                    avg_profile = gaussian_filter1d(avg_profile, sigma=2)  # Apply smoothing
                    plt.plot(avg_profile, label=condition, linewidth=2)
            
            # Add vertical lines to mark TSS and TES
            plt.axvline(x=upstream_bins, color='black', linestyle='--', linewidth=1)
            plt.axvline(x=upstream_bins + gene_body_bins, color='black', linestyle='--', linewidth=1)
            
            # Set title
            plt.title(gene_set_display[gene_set], fontsize=14, fontweight='bold')
            
            # Set x-axis labels
            plt.xticks(xticks, xticklabels, fontsize=12)
            
            # Set y-axis label
            plt.ylabel('log2(S2S/S3)', fontsize=12)
            
            # Add legend
            plt.legend(loc='upper right', fontsize=10)
            
            # Add grid for better readability
            plt.grid(True, linestyle='--', alpha=0.3)
        
        plt.suptitle("Mecp2 repressed genes SAMMY metaprofile - Line Plots", fontsize=18, fontweight='bold')
        
        # Add color interpretation and bin information to the line plot figure
        plt.subplots_adjust(bottom=0.2)  # Make room for the legend
        
        # Add color interpretation text
        color_info_text = (
            "Color Interpretation:\n"
            "Blue (log2(S2S/S3) < 0): Heterochromatin\n"
            "White (log2(S2S/S3) = 0): Undefined regions\n"
            "Red (log2(S2S/S3) > 0): Euchromatin"
        )
        plt.figtext(0.25, 0.08, color_info_text, ha='left', fontsize=12, bbox=dict(facecolor='white', alpha=0.8, boxstyle='round,pad=0.5'))
        
        # Add bin information
        bin_info_text = (
            f"Bin Information:\n"
            f"Upstream region: {upstream_bins} bins (each {bin_size}bp) = {upstream_distance}bp\n"
            f"Gene body: {gene_body_bins} bins (scaled to gene length)\n"
            f"Downstream region: {downstream_bins} bins (each {bin_size}bp) = {downstream_distance}bp"
        )
        plt.figtext(0.75, 0.08, bin_info_text, ha='right', fontsize=12, bbox=dict(facecolor='white', alpha=0.8, boxstyle='round,pad=0.5'))
        
        plt.tight_layout(rect=[0, 0.2, 1, 0.96])
        
        # Save the line plot figure
        line_plot_file = os.path.splitext(output_file)[0] + "_line_plots.png"
        plt.savefig(line_plot_file, dpi=300)
        plt.close()
        
        logger.info(f"Saved comparison heatmap to {output_file}")
        logger.info(f"Saved line plots to {line_plot_file}")
    
    except Exception as e:
        logger.error(f"Error creating comparison heatmap: {e}")

def main():
    """Main function"""
    args = parse_arguments()
    
    # Create output directory
    os.makedirs(args.output_dir, exist_ok=True)
    
    # Load matrices
    condition_matrices = load_matrices(args.input_dir)
    
    if not condition_matrices:
        logger.error("No matrices loaded, exiting")
        sys.exit(1)
    
    # Define gene sets
    gene_sets = ['NEU_target', 'NEU_non_target', 'NSC_target', 'NSC_non_target']
    
    # Find a matrix file to extract parameters
    matrix_files = glob.glob(os.path.join(args.input_dir, "*_matrix.pkl"))
    with open(matrix_files[0], 'rb') as f:
        data = pickle.load(f)
    
    # Extract parameters
    upstream_distance = data['upstream_distance']
    downstream_distance = data['downstream_distance']
    bin_size = data['bin_size']
    gene_body_bins = data['gene_body_bins']
    
    # Calculate bin counts
    upstream_bins = int(upstream_distance / bin_size)
    downstream_bins = int(downstream_distance / bin_size)
    
    # Create comparison heatmap
    output_file = os.path.join(args.output_dir, "mecp2_target_comparison_heatmap.png")
    create_comparison_heatmap(
        gene_sets, 
        condition_matrices, 
        output_file, 
        upstream_bins, 
        gene_body_bins, 
        downstream_bins,
        bin_size,
        upstream_distance,
        downstream_distance
    )
    
    logger.info("Mecp2 target comparison plot generation complete")

if __name__ == "__main__":
    main() 